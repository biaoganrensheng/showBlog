<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>vuex 实用技巧 - Blog - 努力的人生</title>
	<meta name="description" content="vuex 实用技巧">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta property="og:image" content="">
	<link rel="shortcut icon" href="/assets/img/favicon/favicon.ico" type="image/x-icon">
	<link rel="apple-touch-icon" href="/assets/img/favicon/apple-touch-icon.png">
	<link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicon/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicon/apple-touch-icon-114x114.png">
	<!-- Chrome, Firefox OS and Opera -->
	<meta name="theme-color" content="#311e3e">
	<!-- Windows Phone -->
	<meta name="msapplication-navbutton-color" content="#311e3e">
	<!-- iOS Safari -->
	<meta name="apple-mobile-web-app-status-bar-style" content="#311e3e">
	
	
	
	
	<!-- Google Fonts 1
	<link href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Lato:300,400,700" rel="stylesheet">-->
	
	
	
	
	
	<!-- Font Awesome -->
	<link rel="stylesheet" href="/assets/fonts/font-awesome/css/font-awesome.min.css">
	<!-- Styles -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>  
	
	
	<!--百度统计-->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "https://hm.baidu.com/hm.js?660ee541ef48f4a94f8a59dd0f9e64ae";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	
	
	
	
	
	
	
	<!--谷歌统计-->
	<!-- Global site tag (gtag.js) - Google Analytics 
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-113644888-1"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-113644888-1');
	</script>-->

</head>

<body>
  <div class="flex-container">
  <header class="main-header">
  <div class="wrapper">
    <div class="header-flex">
      <div class="menu-icon-container">
        <span class="menu-icon"><i class="fa fa-bars" aria-hidden="true"></i></span>
      </div>
      <nav class="main-nav">
        <span class="menu-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
        <!--<ul style="height:800px;overflow-y:scroll;overflow-y:auto;"> -->
        <ul>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/"  data-hover="所有">所有(32)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/markdown"  data-hover="Markdown">Markdown(4)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/essays"  data-hover="随笔">随笔(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/jekyll"  data-hover="Jekyll">Jekyll(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/vue"  data-hover="Vue">Vue(3)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/react"  data-hover="React">React(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/anglur"  data-hover="Anglur">Anglur(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/youman"  data-hover="构建工具">构建工具(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/nginx2"  data-hover="Nginx2">Nginx2(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/python"  data-hover="Python">Python(2)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/abouttest"  data-hover="测试相关">测试相关(6)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/aboutweb"  data-hover="前端相关">前端相关(1)</a></li>
		 
			 
			 

			 

			 

			 

			 

       

       

       

       

       

       

       

       
       
			 <li><a  href="/blog/other"  data-hover="其它">其它(10)</a></li>
		 
          <!--<li style="margin-bottom:200px;"><a href="/about">About(10)</a></li>-->
        </ul>
      </nav>
      <p class="logo"><a href="/">nldrs</a></p>


		<div class="navbar-container">

		<div class="search-icon"><a><i class="fa fa-search" aria-hidden="true"></i></a></div>

			<div class="navbar-menu">
			   
				<a href="/"  data-hover="Home">Home</a>  <!--title="访问 Home"-->
				<!--<a href="/">Home</a>-->
					
				<a href="/about"  data-hover="About">About</a>  <!--title="访问 About"-->
				<!--<a href="/about">About</a>-->
					
			</div>


			<div class="navbar-mobile-menu" onclick="">
				<span class="icon-menu cross"><span class="middle"></span></span>
				<ul>
				   
					 <li><a href="/"data-hover="Home">Home</a></li>  <!--title="访问 Home"-->
					 <!--<li><a href="/">Home</a></li>-->
				   
					 <li><a href="/about"data-hover="About">About</a></li>  <!--title="访问 About"-->
					 <!--<li><a href="/about">About</a></li>-->
				   
				</ul>
			</div>



		</div>

    <!--  <div class="search-icon-container">
	    <a href="/" style="text-decoration: none; color: inherit;margin-right:20px;">Home</a>
		<a href="/about" style=" text-decoration: none; color: inherit;margin-right:20px;">About</a>
        <span class="search-icon"><a><i class="fa fa-search" aria-hidden="true"></i></a></span>
      </div> -->


    </div>
  </div>
</header> <!-- End Header -->

  <article class="article-page">
    <div class="page-image">
      <div class="cover-image" style="background: url(/assets/img/post-3.jpg) center no-repeat; background-size: cover;"></div>
    </div>
    <div class="wrapper">
      <div class="page-content">
        <div class="header-page">
          <h1 class="page-title">vuex 实用技巧</h1>
          <div class="page-date"><time datetime="2017-03-17 10:01:00 +0800">2017, Mar 17</time>
		  <span id="busuanzi_container_page_pv"> | 访问量：<span id="busuanzi_value_page_pv"></span> 次</span>
		  </div>
        </div>
        <blockquote>
  <p>vuex 是一种状态管理的模式 。</p>
</blockquote>

<ol>
  <li>
    <p>vuex 的状态存储是响应式的。当vue组件 从store中读取状态的时候，若store中的状态发生改变，那么相应的组件也会得到相应的更新
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex的主要作用是将状态（在data中的属性需要共享给其他vue组件使用的部分）单独拎出来，应用统一的方式进行处理，保证各组件间的状态同步（以及同一组件再次显示时的状态保持）。</p>
  </li>
  <li>
    <p>改变store中的状态 唯一途径就是显示提交（commit）mutation</p>
  </li>
</ol>

<p>Vuex 就是前端为了方便数据的操作而建立的一个”前端数据库 ” 
不同的模块组件能通过统一的方法获取，修改数据内容 
store&gt;仓库 
state&gt;源数据 
mutation&gt;Mutations 就是我们把数据存入数据库的 API，用来修改state 的唯一方法 
getter&gt; getters 是我们从数据库里取数据的 API，是一个”纯函数“，不会对原数据造成影响的函数</p>

<p>应用层级的状态应该集中到单个 store 对象中。 
提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 
异步逻辑都应该封装到 action 里面。</p>

<p>1.新建一个store文件夹，并在文件夹下新建index.js文件，文件中引入我们的vue和vuex，引入之后用Vue.use进行引用。
2</p>

<p>2.在main.js 中引入新建的vuex文件，然后 , 在实例化 Vue对象时加入 store 对象 :
import storeConfig from ‘./vuex/store’ new Vue({ el: ‘#app’, router, store,//使用store template: ‘<App></App>’, components: { App } })</p>

<h2 id="一核心概念-state">一.核心概念 （state）</h2>

<p>State负责存储整个应用的状态数据（state就是根据你项目的需求，自己定义一个数据结构，是我们单页应用程序中的共享值），一般需要在使用的时候在跟节点注入Store（相当于仓库）对象（store中至少要注入两项，state 和 mutation）。
在组件使用的过程中，如果想要获取对应的状态你就可以直接使用this.$store.state获取，当然，也可以将 
状态对象赋值给内部对象，也就是把index.js中的值，赋值给我们模板里data中的值。有三种赋值方式
通过computed的计算属性直接赋值 
computed:{count(){return this.$store.state.count;}}
通过mapState的对象来赋值 
import {mapState} from ‘vuex’; computed:mapState({count:state=&gt;state.count }) 
理解为传入state对象，使用ES6的箭头函数来给count赋值,修改state.count属性。
通过mapState的数组来赋值 
computed:mapState([“count”])</p>

<p>vue组件中获得Vuex状态</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建一个 Counter 组件const Counter = {</span>
    <span class="nx">template</span><span class="p">:</span> <span class="s2">`&lt;div&gt;8&lt;/div&gt;`</span><span class="p">,</span>
    <span class="nx">computed</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">count</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span>
  <span class="p">}</span>
<span class="p">}}</span>
</code></pre></div></div>
<ol>
  <li>store.state.count 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM。（然而，这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用 state 的组件中需要频繁地导入，并且在测试组件时需要模拟状态。）
Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：</li>
</ol>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
<span class="na">el</span><span class="p">:</span> <span class="s1">'#app'</span><span class="p">,</span>
<span class="c1">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span>
<span class="nx">store</span><span class="p">,</span>
<span class="na">components</span><span class="p">:</span> <span class="p">{</span> <span class="nx">Counter</span> <span class="p">},</span>
<span class="na">template</span><span class="p">:</span> <span class="s2">`
&lt;div class="app"&gt;
&lt;counter&gt;&lt;/counter&gt;
&lt;/div&gt;
`</span><span class="p">})</span>
</code></pre></div></div>

<p>通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Counter</span> <span class="o">=</span> <span class="p">{</span>
<span class="na">template</span><span class="p">:</span> <span class="s2">`&lt;div&gt;8&lt;/div&gt;`</span><span class="p">,</span>
<span class="na">computed</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">count</span> <span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>
<span class="p">}}</span>
</code></pre></div></div>

<p>mapState</p>

<p>1.当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">computed</span><span class="p">:</span> <span class="nx">mapState</span><span class="p">([</span>
<span class="c1">// 映射 this.count 为 store.state.count</span>
<span class="s1">'count'</span><span class="p">])</span>
</code></pre></div></div>
<p>2.mapState 辅助函数  mapState 传一个对象。</p>

<p>// 在单独构建的版本中辅助函数为 Vuex.mapStateimport { mapState } from ‘vuex’</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="na">computed</span><span class="p">:</span> <span class="nx">mapState</span><span class="p">({</span>
<span class="c1">// 箭头函数可使代码更简练</span>
<span class="na">count</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">,</span>

<span class="c1">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span>
<span class="na">countAlias</span><span class="p">:</span> <span class="s1">'count'</span><span class="p">,</span>

<span class="c1">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span>
<span class="nx">countPlusLocalState</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">localCount</span>
<span class="p">}</span>
<span class="p">})}</span>
</code></pre></div></div>
<p>3.与局部计算属性混合使用。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">computed</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">localComputed</span> <span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">},</span>
<span class="c1">// 使用对象展开运算符将此对象混入到外部对象中</span>
<span class="p">...</span><span class="nx">mapState</span><span class="p">({</span>
<span class="c1">// ...</span>
<span class="p">})}</span>
</code></pre></div></div>
<h2 id="二核心概念-getter">二.核心概念 （Getter）</h2>

<p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>

<p>getters从表面是获得的意思（可以认为是 store 的计算属性）,可以把他看作在获取数据之前进行的一种再编辑,相当于对某些状态做二次处理( 对数据的一个过滤和加工 )。getters 是一个纯函数，接收参数 state，返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
getters基本用法：
比如我们现在要对index.js文件中的count进行一个计算属性的操作，就是在它输出前，给它加上100.我们首先要在index.js里用const声明我们的getters属性。
写好了gettters之后，我们还需要在Vuex.Store()里引入,在index.js里的配置算是完成了，我们需要到模板页对computed进行配置。在vue 的构造器里边只能有一个computed属性，如果你写多个，只有最后一个computed属性可用，所以要对上节课写的computed属性进行一个改造。改造时我们使用ES6中的展开运算符”…”。
或者用mapGetters简化模板写法，将 store 中的 getter 映射到局部计算属性，如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span>
<span class="na">todos</span><span class="p">:</span> <span class="p">[</span>
<span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">text</span><span class="p">:</span> <span class="s1">'...'</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span>
<span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="na">text</span><span class="p">:</span> <span class="s1">'...'</span><span class="p">,</span> <span class="na">done</span><span class="p">:</span> <span class="kc">false</span> <span class="p">}</span>
<span class="p">]</span>
<span class="p">},</span>
<span class="na">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="na">doneTodos</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">todo</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}})</span>
</code></pre></div></div>
<p>通过属性访问
Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值：</p>

<p>store.getters.doneTodos // -&gt; [{ id: 1, text: ‘…’, done: true }]</p>

<p>Getter 也可以接受其他 getter 作为第二个参数：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="nl">doneTodosCount</span><span class="p">:</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">getters</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">getters</span><span class="p">.</span><span class="nx">doneTodos</span><span class="p">.</span><span class="nx">length</span>
<span class="p">}}</span>

<span class="nx">store</span><span class="p">.</span><span class="nx">getters</span><span class="p">.</span><span class="nx">doneTodosCount</span> <span class="c1">// -&gt; 1</span>
</code></pre></div></div>
<p>我们可以很容易地在任何组件中使用它：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">computed</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">doneTodosCount</span> <span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">$store</span><span class="p">.</span><span class="nx">getters</span><span class="p">.</span><span class="nx">doneTodosCount</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>通过方法访问
你也可以通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="nl">getTodoById</span><span class="p">:</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">todo</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span> <span class="o">===</span> <span class="nx">id</span><span class="p">)</span>
<span class="p">}}</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">getters</span><span class="p">.</span><span class="nx">getTodoById</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// -&gt; { id: 2, text: '...', done: false }</span>
</code></pre></div></div>
<p>mapGetters 辅助函数</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>·mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： ```javascript import { mapGetters } from 'vuex'
</code></pre></div></div>

<p>export default {
// …
computed: {
// 使用对象展开运算符将 getter 混入 computed 对象中
…mapGetters([
‘doneTodosCount’,
‘anotherGetter’,
// …
])
}}</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果你想将一个 getter 属性另取一个名字，使用对象形式：
```javascript
mapGetters({
// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`
doneCount: 'doneTodosCount'})
</code></pre></div></div>

<h2 id="三核心概念-mutation">三.核心概念 （Mutation）</h2>

<p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>

<p>最好提前在你的 store 中初始化好所有所需属性。
当需要在对象上添加新属性时，你应该 
使用 Vue.set(obj, ‘newProp’, 123), 或者以新对象替换老对象。 
例如，利用 stage-3 的对象展开运算符我们可以这样写： 
state.obj = { …state.obj, newProp: 123 }</p>

<p>你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store,如上图）。
store.commit(mutationName)是用来触发一个mutation的方法。需要记住的是，定义的mutation必须是同步函数，否则devtool中的数据将可能出现问题，使状态改变变得难以跟踪。</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span>
<span class="na">count</span><span class="p">:</span> <span class="mi">1</span>
<span class="p">},</span>
<span class="na">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">increment</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 变更状态</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="p">}</span>
<span class="p">}})</span>
</code></pre></div></div>
<p>你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p>

<p>store.commit(‘increment’)提交载荷（Payload）
你可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">increment</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="nx">n</span>
<span class="p">}}</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">'increment'</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="nx">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">increment</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">amount</span>
<span class="p">}}</span>

<span class="nx">store</span><span class="p">.</span><span class="nx">commit</span><span class="p">(</span><span class="s1">'increment'</span><span class="p">,</span> <span class="p">{</span>
<span class="na">amount</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
</code></pre></div></div>

<p>对象风格的提交方式
提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">store</span><span class="p">.</span><span class="nx">commit</span><span class="p">({</span>
<span class="na">type</span><span class="p">:</span> <span class="s1">'increment'</span><span class="p">,</span>
<span class="na">amount</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>

<span class="nx">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">increment</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">amount</span>
<span class="p">}}</span>
</code></pre></div></div>

<p>Mutation 需遵守 Vue 的响应规则
既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：
	1. 最好提前在你的 store 中初始化好所有所需属性。
	2. 当需要在对象上添加新属性时，你应该</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* 使用 Vue.set(obj, 'newProp', 123), 或者
* 以新对象替换老对象。例如，利用 stage-3 的对象展开运算符我们可以这样写：state.obj = { ...state.obj, newProp: 123 }
</code></pre></div></div>

<p>使用常量替代 Mutation 事件类型
使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然, 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">SOME_MUTATION</span> <span class="o">=</span> <span class="s1">'SOME_MUTATION'</span>
<span class="c1">// store.jsimport Vuex from 'vuex'import { SOME_MUTATION } from './mutation-types'</span>

<span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>
<span class="p">[</span><span class="nx">SOME_MUTATION</span><span class="p">]</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// mutate state</span>
<span class="p">}</span>
<span class="p">}})</span>
</code></pre></div></div>
<p>Mutation 必须是同步函数</p>

<p>在组件中提交 Mutation
你可以在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p>

<h2 id="四核心概念-action">四.核心概念 （Action）</h2>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。
实践中，我们会经常用到 ES2015 的 参数解构 来简化代码（特别是我们需要调用 commit 很多次的时候）：</p>

<p>Actions也可以用于改变状态，不过是通过触发mutation实现的，重要的是可以包含异步操作。其辅助函数是mapActions与mapMutations类似，也是绑定在组件的methods上的。如果选择直接触发的话，使用this.$store.dispatch(actionName)方法。关于action和mutations的区别有以下几点：</p>

<p>Action 提交的是 mutation，而不是直接变更状态。 
Action 可以包含任意异步操作。 
Action 还是得通过 mutation 方法来修改state</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">increment</span> <span class="p">({</span> <span class="nx">commit</span> <span class="p">})</span> <span class="p">{</span>
<span class="nx">commit</span><span class="p">(</span><span class="s1">'increment'</span><span class="p">)</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>分发 Action
Action 通过 store.dispatch 方法触发：Action 就不受约束！我们可以在 action 内部执行异步操作</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="s1">'increment'</span><span class="p">)</span>

<span class="nx">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">incrementAsync</span> <span class="p">({</span> <span class="nx">commit</span> <span class="p">})</span> <span class="p">{</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">commit</span><span class="p">(</span><span class="s1">'increment'</span><span class="p">)</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 以载荷形式分发</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="s1">'incrementAsync'</span><span class="p">,</span> <span class="p">{</span>
<span class="na">amount</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>

<span class="c1">// 以对象形式分发</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span>
<span class="na">type</span><span class="p">:</span> <span class="s1">'incrementAsync'</span><span class="p">,</span>
<span class="na">amount</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
</code></pre></div></div>
<p>在组件中分发 Action
你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">mapActions</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'vuex'</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
<span class="p">...</span><span class="nx">mapActions</span><span class="p">([</span>
<span class="s1">'increment'</span><span class="p">,</span> <span class="c1">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span>

<span class="c1">// `mapActions` 也支持载荷：</span>
<span class="s1">'incrementBy'</span> <span class="c1">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span>
<span class="p">]),</span>
<span class="p">...</span><span class="nx">mapActions</span><span class="p">({</span>
<span class="na">add</span><span class="p">:</span> <span class="s1">'increment'</span> <span class="c1">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span>
<span class="p">})</span>

<span class="p">}}</span>
</code></pre></div></div>
<p>组合 Action
Action 通常是异步的，那么如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？
首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">actionA</span> <span class="p">({</span> <span class="nx">commit</span> <span class="p">})</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">commit</span><span class="p">(</span><span class="s1">'someMutation'</span><span class="p">)</span>
        <span class="nx">resolve</span><span class="p">()</span>
   <span class="p">},</span> <span class="mi">1000</span><span class="p">)</span>
<span class="p">}),</span>
<span class="nx">actionB</span> <span class="p">({</span> <span class="nx">dispatch</span><span class="p">,</span> <span class="nx">commit</span> <span class="p">})</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">dispatch</span><span class="p">(</span><span class="s1">'actionA'</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">commit</span><span class="p">(</span><span class="s1">'someOtherMutation'</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="p">}}</span>


<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="s1">'actionA'</span><span class="p">).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="c1">// ...})</span>

</code></pre></div></div>
<p>最后，如果我们利用 async / await，我们可以如下组合 action：一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p>

<p>// 假设 getData() 和 getOtherData() 返回的是 Promise</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="k">async</span> <span class="nx">actionA</span> <span class="p">({</span> <span class="nx">commit</span> <span class="p">})</span> <span class="p">{</span>
<span class="nx">commit</span><span class="p">(</span><span class="s1">'gotData'</span><span class="p">,</span> <span class="kr">await</span> <span class="nx">getData</span><span class="p">())</span>
<span class="p">},</span>
<span class="k">async</span> <span class="nx">actionB</span> <span class="p">({</span> <span class="nx">dispatch</span><span class="p">,</span> <span class="nx">commit</span> <span class="p">})</span> <span class="p">{</span>
<span class="kr">await</span> <span class="nx">dispatch</span><span class="p">(</span><span class="s1">'actionA'</span><span class="p">)</span> <span class="c1">// 等待 actionA 完成</span>
<span class="nx">commit</span><span class="p">(</span><span class="s1">'gotOtherData'</span><span class="p">,</span> <span class="kr">await</span> <span class="nx">getOtherData</span><span class="p">())</span>
<span class="p">}}</span>
</code></pre></div></div>
<h2 id="五核心概念-module">五.核心概念 （Module）</h2>

<p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。
为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">moduleA</span> <span class="o">=</span> <span class="p">{</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">mutations</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">actions</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">getters</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}}</span>

<span class="kd">const</span> <span class="nx">moduleB</span> <span class="o">=</span> <span class="p">{</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">mutations</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">actions</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}}</span>

<span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
<span class="na">modules</span><span class="p">:</span> <span class="p">{</span>
<span class="na">a</span><span class="p">:</span> <span class="nx">moduleA</span><span class="p">,</span>
<span class="na">b</span><span class="p">:</span> <span class="nx">moduleB</span>
<span class="p">}})</span>

<span class="nx">store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">a</span> <span class="c1">// -&gt; moduleA 的状态</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">b</span> <span class="c1">// -&gt; moduleB 的状态</span>
</code></pre></div></div>
<p>模块的局部状态
对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">moduleA</span> <span class="o">=</span> <span class="p">{</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="na">count</span><span class="p">:</span> <span class="mi">0</span> <span class="p">},</span>
<span class="na">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">increment</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 这里的 `state` 对象是模块的局部状态</span>
<span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span>
<span class="p">}</span>
<span class="p">},</span>

<span class="na">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">doubleCount</span> <span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">*</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：对于模块内部的 getter，根节点状态会作为第三个参数暴露出来</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">moduleA</span> <span class="o">=</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="na">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">incrementIfOddOnRootSum</span> <span class="p">({</span> <span class="nx">state</span><span class="p">,</span> <span class="nx">commit</span><span class="p">,</span> <span class="nx">rootState</span> <span class="p">})</span> <span class="p">{</span>
<span class="k">if</span> <span class="p">((</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="nx">rootState</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">commit</span><span class="p">(</span><span class="s1">'increment'</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}}</span>

<span class="kd">const</span> <span class="nx">moduleA</span> <span class="o">=</span> <span class="p">{</span>
<span class="c1">// ...</span>
<span class="na">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">sumWithRootCount</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">getters</span><span class="p">,</span> <span class="nx">rootState</span><span class="p">)</span> <span class="p">{</span>
<span class="k">return</span> <span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="nx">rootState</span><span class="p">.</span><span class="nx">count</span>
<span class="p">}</span>
<span class="p">}}</span>
</code></pre></div></div>

<p>命名空间
默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。
如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如：</p>

<p>启用了命名空间的 getter 和 action 会收到局部化的 getter，dispatch 和 commit。换言之，你在使用模块内容（module assets）时不需要在同一模块内额外添加空间名前缀。更改 namespaced 属性后不需要修改模块内的代码。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vuex</span><span class="p">.</span><span class="nx">Store</span><span class="p">({</span>
<span class="na">modules</span><span class="p">:</span> <span class="p">{</span>
<span class="na">account</span><span class="p">:</span> <span class="p">{</span>
<span class="na">namespaced</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>

<span class="c1">// 模块内容（module assets）</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span> <span class="c1">// 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响</span>
<span class="na">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">isAdmin</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// -&gt; getters['account/isAdmin']</span>
<span class="p">},</span>
<span class="na">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">login</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// -&gt; dispatch('account/login')</span>
<span class="p">},</span>
<span class="na">mutations</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">login</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// -&gt; commit('account/login')</span>
<span class="p">},</span>

<span class="c1">// 嵌套模块</span>
<span class="na">modules</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// 继承父模块的命名空间</span>
<span class="na">myPage</span><span class="p">:</span> <span class="p">{</span>
<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">profile</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// -&gt; getters['account/profile']</span>
<span class="p">}</span>
<span class="p">},</span>

<span class="c1">// 进一步嵌套命名空间</span>
<span class="na">posts</span><span class="p">:</span> <span class="p">{</span>
<span class="na">namespaced</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>

<span class="na">state</span><span class="p">:</span> <span class="p">{</span> <span class="p">...</span> <span class="p">},</span>
<span class="na">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">popular</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// -&gt; getters['account/posts/popular']</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}})</span>
</code></pre></div></div>
<p>在带命名空间的模块内访问全局内容（Global Assets）
如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。
若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit 即可。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">modules</span><span class="p">:</span> <span class="p">{</span>
<span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
<span class="nl">namespaced</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>

<span class="nx">getters</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// 在这个模块的 getter 中，`getters` 被局部化了</span>
<span class="c1">// 你可以使用 getter 的第四个参数来调用 `rootGetters`</span>
<span class="nx">someGetter</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">getters</span><span class="p">,</span> <span class="nx">rootState</span><span class="p">,</span> <span class="nx">rootGetters</span><span class="p">)</span> <span class="p">{</span>
<span class="nx">getters</span><span class="p">.</span><span class="nx">someOtherGetter</span> <span class="c1">// -&gt; 'foo/someOtherGetter'</span>
<span class="nx">rootGetters</span><span class="p">.</span><span class="nx">someOtherGetter</span> <span class="c1">// -&gt; 'someOtherGetter'</span>
<span class="p">},</span>
<span class="nx">someOtherGetter</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">},</span>

<span class="nx">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// 在这个模块中， dispatch 和 commit 也被局部化了</span>
<span class="c1">// 他们可以接受 `root` 属性以访问根 dispatch 或 commit</span>
<span class="nx">someAction</span> <span class="p">({</span> <span class="nx">dispatch</span><span class="p">,</span> <span class="nx">commit</span><span class="p">,</span> <span class="nx">getters</span><span class="p">,</span> <span class="nx">rootGetters</span> <span class="p">})</span> <span class="p">{</span>
<span class="nx">getters</span><span class="p">.</span><span class="nx">someGetter</span> <span class="c1">// -&gt; 'foo/someGetter'</span>
<span class="nx">rootGetters</span><span class="p">.</span><span class="nx">someGetter</span> <span class="c1">// -&gt; 'someGetter'</span>

<span class="nx">dispatch</span><span class="p">(</span><span class="s1">'someOtherAction'</span><span class="p">)</span> <span class="c1">// -&gt; 'foo/someOtherAction'</span>
<span class="nx">dispatch</span><span class="p">(</span><span class="s1">'someOtherAction'</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">{</span> <span class="na">root</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="c1">// -&gt; 'someOtherAction'</span>

<span class="nx">commit</span><span class="p">(</span><span class="s1">'someMutation'</span><span class="p">)</span> <span class="c1">// -&gt; 'foo/someMutation'</span>
<span class="nx">commit</span><span class="p">(</span><span class="s1">'someMutation'</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">{</span> <span class="na">root</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="c1">// -&gt; 'someMutation'</span>
<span class="p">},</span>
<span class="nx">someOtherAction</span> <span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>#在带命名空间的模块注册全局 action
若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。例如：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
<span class="nl">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nx">someOtherAction</span> <span class="p">({</span><span class="nx">dispatch</span><span class="p">})</span> <span class="p">{</span>
<span class="nx">dispatch</span><span class="p">(</span><span class="s1">'someAction'</span><span class="p">)</span>
<span class="p">}</span>
<span class="p">},</span>
<span class="nx">modules</span><span class="p">:</span> <span class="p">{</span>
<span class="nl">foo</span><span class="p">:</span> <span class="p">{</span>
<span class="nl">namespaced</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>

<span class="nx">actions</span><span class="p">:</span> <span class="p">{</span>
<span class="nl">someAction</span><span class="p">:</span> <span class="p">{</span>
<span class="nl">root</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
<span class="nx">handler</span> <span class="p">(</span><span class="nx">namespacedContext</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// -&gt; 'someAction'</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>带命名空间的绑定函数
当使用 mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">computed</span><span class="p">:</span> <span class="p">{</span>
<span class="p">...</span><span class="nx">mapState</span><span class="p">({</span>
<span class="na">a</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">some</span><span class="p">.</span><span class="nx">nested</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span>
<span class="na">b</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">some</span><span class="p">.</span><span class="nx">nested</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">b</span>
<span class="p">})},</span>
<span class="nx">methods</span><span class="p">:</span> <span class="p">{</span>
<span class="p">...</span><span class="nx">mapActions</span><span class="p">([</span>
<span class="s1">'some/nested/module/foo'</span><span class="p">,</span>
<span class="s1">'some/nested/module/bar'</span>
<span class="p">])}</span>
</code></pre></div></div>
<p>对于这种情况，你可以将模块的空间名称字符串作为第一个参数传递给上述函数，这样所有绑定都会自动将该模块作为上下文。于是上面的例子可以简化为：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">computed</span><span class="p">:</span> <span class="p">{</span>
<span class="p">...</span><span class="nx">mapState</span><span class="p">(</span><span class="s1">'some/nested/module'</span><span class="p">,</span> <span class="p">{</span>
<span class="na">a</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span>
<span class="na">b</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">b</span>
<span class="p">})},</span>
<span class="nx">methods</span><span class="p">:</span> <span class="p">{</span>
<span class="p">...</span><span class="nx">mapActions</span><span class="p">(</span><span class="s1">'some/nested/module'</span><span class="p">,</span> <span class="p">[</span>
<span class="s1">'foo'</span><span class="p">,</span>
<span class="s1">'bar'</span>
<span class="p">])}</span>
</code></pre></div></div>
<p>而且，你可以通过使用 createNamespacedHelpers 创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">createNamespacedHelpers</span> <span class="p">}</span> <span class="k">from</span> <span class="s1">'vuex'</span>

<span class="kd">const</span> <span class="p">{</span> <span class="nx">mapState</span><span class="p">,</span> <span class="nx">mapActions</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">createNamespacedHelpers</span><span class="p">(</span><span class="s1">'some/nested/module'</span><span class="p">)</span>

<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
<span class="na">computed</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// 在 `some/nested/module` 中查找</span>
<span class="p">...</span><span class="nx">mapState</span><span class="p">({</span>
<span class="na">a</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span>
<span class="na">b</span><span class="p">:</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">b</span>
<span class="p">})</span>
<span class="p">},</span>
<span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
<span class="c1">// 在 `some/nested/module` 中查找</span>
<span class="p">...</span><span class="nx">mapActions</span><span class="p">([</span>
<span class="s1">'foo'</span><span class="p">,</span>
<span class="s1">'bar'</span>
<span class="p">])</span>
<span class="p">}}</span>
</code></pre></div></div>
<p>给插件开发者的注意事项
如果你开发的插件（Plugin）提供了模块并允许用户将其添加到 Vuex store，可能需要考虑模块的空间名称问题。对于这种情况，你可以通过插件的参数对象来允许用户指定空间名称：</p>

<p>// 通过插件的参数对象得到空间名称// 然后返回 Vuex 插件函数export function createPlugin (options = {}) {
return function (store) {
// 把空间名字添加到插件模块的类型（type）中去
const namespace = options.namespace || ‘’
store.dispatch(namespace + ‘pluginAction’)
}}</p>

<p>模块动态注册
在 store 创建之后，你可以使用 store.registerModule 方法注册模块：</p>

<p>// 注册模块 <code class="highlighter-rouge">myModule</code>
store.registerModule(‘myModule’, {
// …})// 注册嵌套模块 <code class="highlighter-rouge">nested/myModule</code>
store.registerModule([‘nested’, ‘myModule’], {
// …})</p>

<p>之后就可以通过 store.state.myModule 和 store.state.nested.myModule 访问模块的状态。
模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态。例如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。
你也可以使用 store.unregisterModule(moduleName) 来动态卸载模块。注意，你不能使用此方法卸载静态模块（即创建 store 时声明的模块）。
在注册一个新 module 时，你很有可能想保留过去的 state，例如从一个服务端渲染的应用保留 state。你可以通过 preserveState 选项将其归档：store.registerModule(‘a’, module, { preserveState: true })</p>

<p>模块重用
有时我们可能需要创建一个模块的多个实例，例如：
	* 创建多个 store，他们公用同一个模块 (例如当 runInNewContext 选项是 false 或 ‘once’ 时，为了在服务端渲染中避免有状态的单例)
	* 在一个 store 中多次注册同一个模块</p>

<p>如果我们使用一个纯对象来声明模块的状态，那么这个状态对象会通过引用被共享，导致状态对象被修改时 store 或模块间数据互相污染的问题。
实际上这和 Vue 组件内的 data 是同样的问题。因此解决办法也是相同的——使用一个函数来声明模块状态（仅 2.3.0+ 支持）：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">MyReusableModule</span> <span class="o">=</span> <span class="p">{</span>
<span class="nx">state</span> <span class="p">()</span> <span class="p">{</span>
<span class="k">return</span> <span class="p">{</span>
<span class="na">foo</span><span class="p">:</span> <span class="s1">'bar'</span>
<span class="p">}</span>
<span class="p">},</span>
<span class="c1">// mutation, action 和 getter 等等...}</span>
</code></pre></div></div>

<p>项目结构
Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：
	1. 应用层级的状态应该集中到单个 store 对象中。
	2. 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。
	3. 异步逻辑都应该封装到 action 里面。</p>

<p>只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。
对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">├──</span> <span class="nx">index</span><span class="p">.</span><span class="nx">html</span>
<span class="err">├──</span> <span class="nx">main</span><span class="p">.</span><span class="nx">js</span>
<span class="err">├──</span> <span class="nx">api</span>
<span class="err">│</span> <span class="err">└──</span> <span class="p">...</span> <span class="err">#</span> <span class="err">抽取出</span><span class="nx">API</span><span class="err">请求</span>
<span class="err">├──</span> <span class="nx">components</span>
<span class="err">│</span> <span class="err">├──</span> <span class="nx">App</span><span class="p">.</span><span class="nx">vue</span>
<span class="err">│</span> <span class="err">└──</span> <span class="p">...</span>
<span class="err">└──</span> <span class="nx">store</span>
<span class="err">├──</span> <span class="nx">index</span><span class="p">.</span><span class="nx">js</span> <span class="err">#</span> <span class="err">我们组装模块并导出</span> <span class="nx">store</span> <span class="err">的地方</span>
<span class="err">├──</span> <span class="nx">actions</span><span class="p">.</span><span class="nx">js</span> <span class="err">#</span> <span class="err">根级别的</span> <span class="nx">action</span>
<span class="err">├──</span> <span class="nx">mutations</span><span class="p">.</span><span class="nx">js</span> <span class="err">#</span> <span class="err">根级别的</span> <span class="nx">mutation</span>
<span class="err">└──</span> <span class="nx">modules</span>
<span class="err">├──</span> <span class="nx">cart</span><span class="p">.</span><span class="nx">js</span> <span class="err">#</span> <span class="err">购物车模块</span>
<span class="err">└──</span> <span class="nx">products</span><span class="p">.</span><span class="nx">js</span> <span class="err">#</span> <span class="err">产品模块</span>

</code></pre></div></div>

        <div class="page-footer">
          <div class="page-tag">
            <span>Tags:</span>
            
            <a href="/tags#Vue" class="tag">| Vue</a>
            
            <a href="/tags#vuex" class="tag">| vuex</a>
            
          </div><!-- End Tags -->
          <div class="page-share">
            <span>Share:</span>
            <a href="https://twitter.com/intent/tweet?text=vuex 实用技巧&url=http://localhost:4000/vue2/" title="Share on Twitter" rel="nofollow" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a>
            <a href="https://facebook.com/sharer.php?u=http://localhost:4000/vue2/" title="Share on Facebook" rel="nofollow" target="_blank"><i class="fa fa-facebook" aria-hidden="true"></i></a>
            <a href="https://plus.google.com/share?url=http://localhost:4000/vue2/" title="Share on Google+" rel="nofollow" target="_blank"><i class="fa fa-google" aria-hidden="true"></i></a>
						
			<!-- JiaThis Button BEGIN -->
			<div class="jiathis_style_32x32">
				<a class="jiathis_button_weixin"></a>
				<a class="jiathis_button_tsina"></a>
				<!--<a class="jiathis_button_tqq"></a>
				<a class="jiathis_button_qzone"></a>
				<a class="jiathis_button_renren"></a>-->
				<a href="http://www.jiathis.com/share?uid=2157296" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
				<a class="jiathis_counter_style"></a>
			</div>
			<script type="text/javascript">var jiathis_config = {data_track_clickback:'true'};</script>
			<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=2157296" charset="utf-8"></script>
			<!-- JiaThis Button END -->
          </div><!-- End Share -->
		  
		
		  
		  <section>
			<!--<div style="background:#000;border-bottom: 1px solid #d9d9d9;"></div> -->

            <div class="content-play">
              <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang" title="打赏，支持一下">打赏一下呗</a></p>
              <div class="hide_box-play"></div>
              <div class="shang_box-play">
                <a class="shang_close-play" href="javascript:void(0)" onclick="dashangToggle()" title="关闭"><img src="/assets/img/close.jpg" alt="取消" /></a>
                <div class="shang_tit-play">
                  <p>对你有帮助，那就打赏一下吧</p>
                </div>
				
				<div class="shang_payimg">    
                    <img src="/assets/img/wechatimg.jpg" alt="扫码支持" title="扫一扫"/>
                </div>
				
				 <div class="pay_item" data-id="weipay">
                    <span class="pay_logo"><img src="/assets/img/wechat.jpg" alt="微信" /></span>
                  </div>
				
                <div class="shang_payimg">
                    <img src="/assets/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
                </div>
				
				 <div class="pay_item checked" data-id="alipay">
                    <span class="pay_logo"><img src="/assets/img/alipay.jpg" alt="支付宝" /></span>
                  </div>
				
                <div class="pay_explain">扫码打赏,金额随意</div>
               
              </div>
            </div>
            <script type="text/javascript">
            function dashangToggle(){
              $(".hide_box-play").fadeToggle();
              $(".shang_box-play").fadeToggle();
            }
            </script>

            <div style="text-align:center;margin:50px 0; font:normal 14px/24px 'MicroSoft YaHei';"></div>

            <style type="text/css">
              .content-play{width:100%;margin-top: 20px;margin-bottom: 10px;height:40px;text-align:center;}
              .hide_box-play{z-index:999;filter:alpha(opacity=50);background:#666;opacity: 0.5;-moz-opacity: 0.5;left:0;top:0;height:99%;width:100%;position:fixed;display:none;}
              .shang_box-play{width:100%;height:540px;padding:10px;background-color:#fff;border-radius:10px;position:fixed;z-index:1000;left:0%;top:50%;margin-left:0px;margin-top:-280px;border:1px dotted #dedede;display:none;}
              .shang_box-play img{border:none;border-width:0;}
              .dashang{width:100px;margin:5px auto;height:25px;line-height:25px;padding:10px;background-color:#E74851;color:#fff;text-align:center;text-decoration:none;border-radius:10px;font-weight:bold;font-size:16px;transition: all 0.3s;}
              .dashang:hover{opacity:0.8;padding:15px;font-size:18px;}
              .shang_close-play{float:right;display:inline-block;
                margin-right: 10px;margin-top: 20px;
              }
              .shang_logo{display:block;text-align:center;margin:20px auto;}
              .shang_tit-play{width: 100%;height: 75px;text-align: center;line-height: 66px;color: #a3a3a3;font-size: 16px;background: url('/images/payimg/cy-reward-title-bg.jpg');font-family: 'Microsoft YaHei';margin-top: 7px;margin-right:2px;}
              .shang_tit-play p{color:#a3a3a3;text-align:center;font-size:16px;}
              .shang_payimg{padding:10px;/*border:6px solid #EA5F00;**/margin:0 auto;border-radius:3px;height:140px;display:inline-block;}
              .shang_payimg img{display:inline-block;margin-right:10px;float:left;text-align:center;width:140px;height:140px; }
              .pay_explain{text-align:center;margin:10px auto;font-size:12px;color:#545454;}
              .shang_payselect{text-align:center;margin:0 auto;margin-top:40px;cursor:pointer;height:60px;width:500px;margin-left:110px;}
              .shang_payselect .pay_item{display:inline-block;margin-right:140px;float:left;}
              .shang_info-play{clear:both;}
              .shang_info-play p,.shang_info-play a{color:#C3C3C3;text-align:center;font-size:12px;text-decoration:none;line-height:2em;}
            </style>

       <ul class="pager">
	    
        <li class="previous">
            <a href="/vue3/" data-toggle="tooltip" data-placement="top" title="vueRouter 实用技巧">上一篇：  <span>vueRouter 实用技巧</span>
            </a>
        </li>
		
		<br><br>
		
        
        
        <li class="next">
            <a href="/vue1/" data-toggle="tooltip" data-placement="top" title="vue 实用技巧">下一篇：  <span>vue 实用技巧</span>
            </a>
        </li>
        
    </ul>
</section>

        </div>
		
		
        <section class="author-box">
  <img src="/assets/img/leach-face.jpg" alt="nldrs" class="author-img">
  <div class="author-desc">
    <h2>nldrs</h2>
    <p>码农，嘿说你呢！！？</p>
    <ul>
      
        <li class="email"><a href="mailto:lpfwch777@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
      
      
        <li class="phone"><a href="tel:0"><i class="fa fa-phone"></i></a></li>
      
      <!--
        <li class="website"><a href="https://artemsheludko.github.io" target="_blank"><i class="fa fa-globe" aria-hidden="true"></i></a></li>
      
      
        <li class="twitter"><a href="https://twitter.com/artemsheludko_" target="_blank"><i class="fa fa-twitter" aria-hidden="true"></i></a></li>
      -->
    </ul>
  </div>
</section>

        <div class="recent-box">
  <h2 class="recent-title">Recent post</h2>
  <div class="recent-list">
    
      
        <a href="/web/" class="recent-item" style="background: url(/assets/img/post-8.jpg) center no-repeat; background-size: cover;"><span>前端相关</span></a>
      
    
      
        <a href="/react1/" class="recent-item" style="background: url(/assets/img/post-1.jpg) center no-repeat; background-size: cover;"><span>react redux 基本用法</span></a>
      
    
      
        <a href="/car-yangjiaolian/" class="recent-item" style="background: url(/assets/img/post-2.jpg) center no-repeat; background-size: cover;"><span>科目三笔记二</span></a>
      
    
      
        <a href="/car-liujiaolian/" class="recent-item" style="background: url(/assets/img/post-4.jpg) center no-repeat; background-size: cover;"><span>科三笔记一</span></a>
      
    
  </div>
</div> <!-- End Recent-Box -->

        <div class="newsletter" id="mc_embed_signup" style="display:none">
  <h2 class="newsletter-title">Newsletter</h2>
  <div class="form-container">
    <p>Subscribe here to get our latest updates</p>
    <form action="//" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
      <label class="screen-reader-text" for="mce-EMAIL">Email Address</label>
      <div class="newsletter-box" id="mc_embed_signup_scroll">
        <input type="email" name="EMAIL" placeholder="Email address" class="email-input" id="mce-EMAIL" required>
        <input type="submit" value="Subscribe" name="subscribe" class="subscribe-btn" id="mc-embedded-subscribe">
      </div>
    </form>
  </div>
</div> <!-- End Newsletter -->

        <section class="comment-area">
  <div class="comment-wrapper">
   
	  <div id="disqus_thread" class="article-comments"></div>
	    <script>
			var idcomments_acct = '8b1583de29c0b1f23510ee43fce7d4e7';
			var idcomments_post_id;
			var idcomments_post_url;
		</script>
		<span id="IDCommentsPostTitle" style="display:none"></span>
		<script type='text/javascript' src='https://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
	
  </div>
</section>
      </div>
    </div> <!-- End Wrapper -->
  </article>
  <div class="search-box">
  <div class="wrapper">
    <div class="search-grid">
      <form class="search-form">
        <div id="search-container">
          <input type="text" id="search-input" class="search" placeholder="Search">
        </div>
      </form>
      <ul id="results-container" class="results-search"  style="height:400px;overflow-y:scroll;overflow-y:auto;"></ul>
      <div class="icon-close-container">
        <span class="search-icon-close"><i class="fa fa-times" aria-hidden="true"></i></span>
      </div>
    </div>
  </div>
</div>

  <footer class="main-footer">
	<div class="footer-social">
		<div class="footer-container clearfix">
			<div class="social-list">
				<a class="social github" target="blank" href="https://github.com/nldrs">GitHub</a>
				<a class="social github" target="blank" href="https://www.jianshu.com/u/042fe873dc7c">简书</a>
				<a class="social github" target="blank" href="https://juejin.im/user/5a20a378f265da4311200031/collections">掘金</a>
				<a class="social github" target="blank" href="http://blog.csdn.net/">Csdn</a>
			</div>
		</div>
	</div>

	<div class="copyright">
		<p>2018 &copy; nldrs</p>
		
			
	<div style="font-size:12px;color:#B3B3B3;padding-right:30px;float:right"> 
		<iframe
                style="margin-left: 2px; margin-bottom:-5px;"
                frameborder="0" scrolling="0" width="91px" height="20px"
                src="https://ghbtns.com/github-btn.html?user=leach-chen&repo=leach-chen.github.io&type=star&count=true" >
            </iframe>
		<span id="busuanzi_container_site_pv">本站总访问量：<span id="busuanzi_value_site_pv"></span>次</span>
	</div>
	</div>

</footer> <!-- End Footer -->

</div>

  
  
<div class="top" title="Top"><i class="fa fa-chevron-up" aria-hidden="true"></i></div> <!-- End Top Scroll -->
  <!-- JS -->
<script src="/assets/js/jquery-3.2.1.min.js"></script>
<script src="/assets/js/jekyll-search.js"></script>
<script>
  SimpleJekyllSearch({
    searchInput: document.getElementById('search-input'),
    resultsContainer: document.getElementById('results-container'),
    json: '/search.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
    noResultsText: 'No results found',
    fuzzy: false,
    exclude: ['Welcome']
  });
</script>
<script src="/assets/js/main.js"></script>

  <!--<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '', 'auto');
  ga('send', 'pageview');
</script> <!-- End Analytics -->

</body>
</html>
